# üìò Travel Journal ‚Äî Technical Design Document (Implementation-ready)

> Single-author travel-journal system: an **Expo React Native** app for writing/publishing, and a **Next.js** web app for readers.
> Media are stored in **Google Photos** shared album(s). Content (stories) are Markdown files committed to a GitHub repo (directly to `main`) using a **fine-grained PAT**. Vercel builds the web app on every push.

This doc collects all tech decisions, researched constraints, API flows, data formats, repo layout, security practices, offline behavior, and the exact sequence of implementation steps you will need to implement everything reliably.

---

# Table of contents

1. Goals & Constraints
2. High-level architecture overview
3. Data model (Markdown / frontmatter)
4. Google Photos: design decisions, APIs, flows, pitfalls, and exact calls
5. GitHub integration: PATs, Contents API, flows, calls, security
6. End-to-end publish flow (detailed sequence)
7. App & Web responsibilities (what each does)
8. Repo layout (final folder structure)
9. Local development & testing strategy
10. CI / GitHub Actions recommendations (pre-merge checks)
11. Offline / retry / error handling design
12. Security & operational notes (tokens, rotation, reauth)
13. Sample payloads & code snippets (HTTP + pseudocode)
14. Implementation checklist & rollout plan
15. Appendix: references & research summary

---

# 1 ‚Äî Goals & Constraints

**Primary goal:** give you a frictionless, single-author workflow where you can write on your phone, select media from Google Photos, press **Publish**, and have a polished story appear on your site.

**Key constraints / user choices**

* Single user (you). App is personal.
* Expo React Native + React Navigation for mobile app.
* Next.js for web app (deployed to Vercel).
* Google Photos Picker / Photos Library API for media selection and a programmatic shared album (`albums.share`).
* Use **one** persistent shared album (reused) for all published media; app creates it and reuses its `albumId`.
* Stories stored as Markdown files in GitHub `stories/` folder (flat); mobile app generates filenames (slugs).
* No monorepo tooling (no Turborepo/Nx). Simple repo layout: `webapp/`, `app/`, `.github/`, etc.
* Direct push to `main` always; CI must prevent broken commits (build + validations).
* Album links used everywhere for media (link to shared album), not per-item long-lived URLs (because baseUrls are short-lived).

---

# 2 ‚Äî High-level architecture

```
[Mobile App (Expo) - single user]
  - Google OAuth (test mode) --> Picker session
  - Google Photos Library API for album creation/sharing/batchAdd
  - GitHub PAT (fine-grained) stored locally
  - Creates slugged markdown file
  - Commits file to GitHub via Contents API
      ‚Üì
[GitHub repo: stories/*.md] (push to main)
      ‚Üì
[Vercel] (auto-deploy on push)
      ‚Üì
[Web App (Next.js)] renders stories statically from markdown
      ‚Üì
Public readers view stories; album share URL (Google Photos) opens album to view images/videos.
```

Key external services: Google Photos API, GitHub API, Vercel.

---

# 3 ‚Äî Data model (Markdown + frontmatter)

Each story is a Markdown file in `stories/` with YAML frontmatter. Files are flat in `stories/` (no year folders).

### Example file: `stories/2025-03-28-bangkok-morning-walk.md`

```md
---
title: "Slow Morning in Bangkok"
date: "2025-03-28"
slug: "2025-03-28-bangkok-morning-walk"
location: "Bangkok, Thailand"
album_share_url: "https://photos.app.goo.gl/ABCDE..."
album_id: "ABcDeFg12345"        # Google Photos albumId (optional)
media_item_ids:
  - "ABC123"
  - "DEF456"
tags:
  - morning
  - reflection
draft: false
---
Body content in Markdown...

You can optionally include inline references to the album or item ids. For reader-facing pages, the web app will show the album link and may display thumbnails fetched at render-time or client-side.
```

**Notes**

* `slug` is generated by mobile app and used as filename.
* `album_share_url` is the public URL your app obtains from `albums.share`. This is what readers will use.
* `media_item_ids` is optional but useful to maintain a mapping to items inside the album (for future rehosting or item-level features).
* Do **not** embed `baseUrl` as permanent public URLs. `baseUrl` is short-lived (~60 min) and requires Authorization.

---

# 4 ‚Äî Google Photos: decisions, flows, and API details

### Research summary (short)

* The Google Photos Library API (and Picker) are the right tools to *select* and *programmatically add* existing media into albums. `albums.share` returns a `shareableUrl` (public link) that readers can view.
* `baseUrl` returned for individual media is short-lived and is **not** a stable public link for readers ‚Äî do not embed it as a permanent asset.
* `albums.share` can only be used on albums **created by your app via the API**. To be able to share programmatically, create and reuse the album via the Library API.
* For single-user testing, you can use OAuth consent in *Testing* and add your account as a test user. Test authorizations may expire (re-auth every 7 days is expected unless you verify the app for production).

### OAuth & Scopes

You will need:

* OAuth client (Android) configured in Google Cloud Console (package name + SHA-1).
* Scopes to request:

  * `https://www.googleapis.com/auth/photoslibrary.readonly` ‚Äî read-only media (if only reading)
  * `https://www.googleapis.com/auth/photoslibrary.appendonly` ‚Äî append items (if only adding)
  * `https://www.googleapis.com/auth/photoslibrary.sharing` ‚Äî required to call `albums.share`
  * Depending on flow, you may need full `photoslibrary` scopes. Request minimal scopes required.

**Testing mode:** use External/Test with your account as test user.

### Core API calls you'll use (summary)

1. **Create album**

   ```
   POST https://photoslibrary.googleapis.com/v1/albums
   Authorization: Bearer <GOOGLE_ACCESS_TOKEN>
   Content-Type: application/json

   { "album": { "title": "Tirtha-Journal-Shared" } }
   ```

   ‚Üí response `album.id`

2. **Share album**

   ```
   POST https://photoslibrary.googleapis.com/v1/albums/{albumId}:share
   Authorization: Bearer <GOOGLE_ACCESS_TOKEN>
   Content-Type: application/json

   { "sharedAlbumOptions": { "isCollaborative": false, "isCommentable": false } }
   ```

   ‚Üí response `shareInfo.shareableUrl` and `shareToken`

3. **List albums (optionally only app-created)**

   ```
   GET https://photoslibrary.googleapis.com/v1/albums?excludeNonAppCreatedData=true
   Authorization: Bearer <GOOGLE_ACCESS_TOKEN>
   ```

4. **Get album metadata**

   ```
   GET https://photoslibrary.googleapis.com/v1/albums/{albumId}
   Authorization: Bearer <GOOGLE_ACCESS_TOKEN>
   ```

5. **Batch-add media to album**

   ```
   POST https://photoslibrary.googleapis.com/v1/albums/{albumId}:batchAddMediaItems
   Authorization: Bearer <GOOGLE_ACCESS_TOKEN>
   Content-Type: application/json

   { "mediaItemIds": ["ABC123","DEF456"] }
   ```

6. **(Picker)** Use the Picker session flow:

   * Create a Picker session and open it (per Picker API docs), then poll session for selected `mediaItemIds` (Picker flow is client-driven and requires a valid access token before creating the session).

### Reuse / idempotency notes

* Store `albumId` locally in secure app storage. Before creating a new album, check `albums.get` and `albums.list?excludeNonAppCreatedData=true`. If `albumId` exists and album still present, reuse it.
* If album gets deleted/unshared, app should recreate & re-share and update saved `albumId` and `album_share_url`.
* `albums.share` sets link sharing; once shared the `shareableUrl` remains valid until share is disabled.

### Pitfalls & workarounds

* **Picker / baseUrl expiry**: `baseUrl` is temporary. Use album sharing for readers, not baseUrl.
* **Albums created outside your app**: `albums.share` via API only works for albums **created by your app**. Creating albums through the API from the app is required for programmatic shareability.
* **OAuth testing expiry**: in Testing mode tokens/consents can expire; you‚Äôll need to handle reauth gracefully.

---

# 5 ‚Äî GitHub integration: PAT usage, API, and security

### Research summary (short)

* A mobile app can commit markdown to a repo using GitHub APIs. For simple create/update of single files, the **Contents API** (REST `PUT /repos/{owner}/{repo}/contents/{path}`) is straightforward.
* Use **fine-grained PATs** (repo-scoped, limited permissions) rather than classic PATs. Fine-grained tokens can be restricted to a single repo and specific permissions (contents write). Set a reasonable expiry (30/90 days).
* Storing PAT in the APK is sensitive; store the PAT securely on device using Android Keystore + EncryptedSharedPreferences (or SecureStore in Expo if you use SecureStore backed by native keystore).

### PAT vs GitHub App

* **PAT (fine-grained)**: easiest for a single-user personal app. Short-lived tokens, repo-scoped.
* **GitHub App**: better security for multi-user or production-grade integrations (short-lived installation tokens), but more setup. For now use a fine-grained PAT.

### Core GitHub calls for create/update file

1. **Check for file (GET)**

   ```
   GET https://api.github.com/repos/{owner}/{repo}/contents/stories/{filename}.md
   Authorization: Bearer <GITHUB_PAT>
   Accept: application/vnd.github+json
   ```

   * If 200 ‚Üí parse `sha` for updates; if 404 ‚Üí create.

2. **Create new file (PUT)**

   ```
   PUT https://api.github.com/repos/{owner}/{repo}/contents/stories/{filename}.md
   Authorization: Bearer <GITHUB_PAT>
   Accept: application/vnd.github+json

   {
     "message": "Add story: <title>",
     "content": "<BASE64_MARKDOWN>",
     "committer": { "name":"Tirtha", "email":"you@example.com" },
     "branch": "main"
   }
   ```

3. **Update existing file (PUT with sha)**
   Same as above, but include `"sha": "<current_sha>"`.

### Multi-file atomic commit (if needed)

* For atomic multi-file commits use the GraphQL `createCommitOnBranch` mutation or the Git Database API. For current use-case single-file PUTs are fine.

### Rate limits

* Standard authenticated REST limits apply (e.g., ~5,000/hour) which is plenty for single-user occasional commits.

### Security & storage on device

* **Do not** hardcode PAT in code. Let the user paste it once in app settings.
* Store using: **Android Keystore** + **EncryptedSharedPreferences** (or Expo SecureStore which uses platform keystore). Provide an in-app UI to replace/revoke PAT.
* Recommend PAT expiry = 30‚Äì90 days. Provide quick re-entry workflow.

---

# 6 ‚Äî Full End-to-end publish flow (detailed sequence)

This section binds Google Photos flow + GitHub commit flow into one publish sequence.

### Preconditions

* App has valid Google OAuth token (or user will reauth in testing mode) and valid GitHub PAT stored.
* `albumId` may or may not exist locally.

### 0. Local draft creation (offline allowed)

* User writes story, adds title/date/location/tags, selects media (invokes Picker).
* Save draft locally (draft file + `mediaItemIds`).

### 1. Picker selection

* App creates Picker session (requires Google access token).
* User selects media in Google Photos UI; Picker returns `mediaItemIds` (and possibly `baseUrl` for immediate preview).

### 2. Ensure shared album (create or reuse)

* If no `albumId` in app state:

  * `POST /v1/albums` ‚Üí save `albumId`.
  * `POST /v1/albums/{albumId}:share` ‚Üí save `shareInfo.shareableUrl`.
* If `albumId` exists:

  * `GET /v1/albums/{albumId}` ‚Üí verify album exists; if not, recreate+reshare.
  * If `shareInfo` missing, call `albums.share`.

### 3. Add selected media to album

* `POST /v1/albums/{albumId}:batchAddMediaItems` with `mediaItemIds`.

### 4. Build Markdown file

* Compose frontmatter including `album_share_url` and `album_id` and any `media_item_ids`.
* Mobile app generates slugified filename and writes Markdown content (string).

### 5. Commit Markdown to GitHub (Contents API)

* `GET /repos/{owner}/{repo}/contents/stories/{filename}` to learn if exists (get `sha`).
* `PUT /repos/{owner}/{repo}/contents/stories/{filename}.md` with message + base64 content (+ sha for update).

### 6. Vercel build & publish

* GitHub push triggers Vercel; site rebuilds reading `stories/*.md`. Static story page is generated and available publicly.

### 7. Reader experience

* Reader opens page; the web app displays story and shows `album_share_url` as primary media link. Clicking it opens the public Google Photos album (hosted by Google) showing images/videos.

---

# 7 ‚Äî App vs Web responsibilities

### Mobile App (Expo RN)

* User authentication flows:

  * Google OAuth + Picker session creation
  * Secure storage & management of GitHub PAT
* Draft authoring UI (Markdown editor)
* Media selection via Picker, and submitting `mediaItemIds`
* Reuse/create/share album via Photos Library API
* Build Markdown story and commit via GitHub API
* Offline-first storage (local drafts)
* Retry logic & progress UI during publish

### Web App (Next.js)

* Render markdown `stories/*.md` to static pages (SSG)
* Provide cozy-journal UI (fonts, polaroid media embeds, album link)
* Optionally display album preview or embed if feasible (embed via `album_share_url`)
* Validate frontmatter during build; fail build if invalid (CI catches earlier)
* No Google auth or media hosting responsibilities (only reads album URL)

---

# 8 ‚Äî Repo layout (final; flat structure, no monorepo tooling)

Top-level repo layout you requested:

```
/journal-repo
  /app               # Expo React Native app (mobile author app)
    app.json
    package.json
    src/
      screens/
      services/
        googlePhotosService.ts
        githubService.ts
      components/
      util/
  /webapp            # Next.js app (public site)
    next.config.js
    package.json
    pages/ or app/
    components/
    lib/
    stories/         # final canonical content folder read by Next.js
      2025-03-28-bangkok-morning-walk.md
      2025-04-01-chiangmai-coffee.md
  /.github
    workflows/
      ci.yml         # CI checks: lint, test, build, markdown frontmatter validation
  /scripts
    validate-stories.js    # CLI script for frontmatter validation, slug checks
    slugify.js
  .vercel                # optional / vercel config
  README.md
  LICENSE
```

**Notes**

* `stories/` is in `webapp/stories/` (or at top-level and consumed by webapp). Because you push directly to `main`, Vercel will build based on `webapp/` project config. I recommend keeping `stories/` at repo root (for easy GitHub creations) and configuring Next.js to read from `../stories` relative path or copying stories into `webapp/stories` at build; but simplest: keep `stories/` at repo root and configure Next.js to read from `../stories` (or set `contentDir` env var). Example final layout updated:

```
/journal-repo
  /app
  /webapp
  /stories
  /.github
  /scripts
  package.json
```

* Keep a small `scripts/validate-stories.js` to ensure frontmatter conforms and filenames are valid ‚Äî run in CI.

---

# 9 ‚Äî Local dev & testing strategy (no monorepo tool)

You said ‚Äúno monorepo tool‚Äù, so use standard npm/yarn workspaces minimally (or none). Recommended approach:

* Use **two terminal windows** / two processes:

  * `cd webapp && pnpm dev` ‚Äî local Next.js dev server (reads from `../stories`).
  * `cd app && expo start` ‚Äî run Expo dev server for mobile app.

**Testing interactions**

* To emulate publish locally:

  * Mobile app can have a ‚Äúlocal publish‚Äù mode that writes files to a local `stories/` folder instead of committing to GitHub (useful for testing).
  * Provide config flags (ENV) in app: `GITHUB_LOCAL_SYNC=true` writes to local FS path (only for desktop/dev).
  * Use `ngrok` if you need to test callbacks or external endpoints.

**Local validation**

* `node scripts/validate-stories.js` runs checks on `stories/`:

  * required frontmatter fields
  * unique slugs/filenames
  * date format
  * allowed tag values

**Simulating Google Photos**

* For local dev, provide a fake picker flow that returns mock `mediaItemIds` and an optional `album_share_url` to emulate the API responses. This speeds development without real Google OAuth.

**Running CI locally**

* Use `act` or run GitHub Actions workflows locally if needed, or just run the same commands locally:

  * `pnpm -w lint`
  * `pnpm -w test`
  * `node scripts/validate-stories.js`
  * `cd webapp && pnpm build` (simulate Vercel build)

---

# 10 ‚Äî CI / GitHub Actions (recommended workflows)

Because you push directly to `main`, CI must be strict:

`.github/workflows/ci.yml` (high-level)

* Trigger: `push` to `main` (or all branches if desired)
* Jobs:

  1. **validate**: run `scripts/validate-stories.js` to ensure frontmatter and filenames OK.
  2. **lint**: run ESLint for `app` and `webapp`.
  3. **typecheck**: run TypeScript checks for both projects.
  4. **build-web**: `pnpm --filter webapp build` to ensure Next.js builds (fail fast).
  5. **optional tests**: unit tests for shared utilities.

If CI fails, Vercel will not receive good content (or Vercel may still build, but you should treat CI as the gate‚Äîconsider disabling direct GitHub ‚Üí Vercel auto-deploy if CI fails; you can require GitHub branch protection, but you said direct-to-main. Instead make GitHub Action fail the commit by rejecting merge‚Äîthough pushing is already done. So protect `main` by requiring passing checks on PRs if you ever change workflow. For now, CI acts as a monitoring/failing notifier and you fix after push.)

**Note on direct pushes**: Since you‚Äôll push directly to `main`, you must rely on CI + build-time validations to catch issues early. Consider enabling branch protection (optional) later.

---

# 11 ‚Äî Offline, retry, and error handling design

### Mobile app must be resilient:

* **Drafts** are stored in a local DB (AsyncStorage + small DB like WatermelonDB or SQLite) ‚Äî simple AsyncStorage is fine for initial version.
* **Publish queue**: when publish is clicked but network absent or tokens expired, enqueue a publish job in local queue.
* **Retry behavior**:

  * For transient errors (5xx): exponential backoff (1s ‚Üí 2s ‚Üí 4s ‚Üí 8s, up to N attempts).
  * For auth errors (401): prompt re-auth (Google) or ask to re-enter PAT (GitHub).
* **Partial failure safety**:

  * If adding media to album succeeds but GitHub commit fails, keep media in album and mark draft as "media uploaded" so you can retry commit without re-adding media. Also keep mapping of `media_item_ids` and `album_id` in draft.
  * If commit succeeds but Vercel build fails, the commit remains in repo; you can fix content in subsequent commits.

---

# 12 ‚Äî Security & operational notes

### Google OAuth & Testing mode

* Use Testing mode initially; add your account as test user.
* Expect re-auth every ~7 days for test app tokens; implement re-auth flow and good UX notifications.

### GitHub PAT

* Use fine-grained PAT with minimal repo access and limited lifetime (30‚Äì90 days).
* Store PAT encrypted (Android Keystore / Expo SecureStore).
* Provide UI to paste/replace/revoke token.
* If token compromised: revoke instantly via GitHub.

### Data privacy

* Your repo will contain published stories (public or private depending on repo visibility); treat secrets carefully (do not commit tokens or private keys).
* Use `.env` for local dev; never commit env files.

### Logging & monitoring

* App should log publish attempts & failures locally; optionally send anonymized logs to a logging service (optional).
* Monitor Vercel builds and GitHub Actions for failures.

---

# 13 ‚Äî Sample requests & pseudocode

### Google: create & share album (HTTP)

```http
POST https://photoslibrary.googleapis.com/v1/albums
Authorization: Bearer <GOOGLE_ACCESS_TOKEN>
Content-Type: application/json

{ "album": {"title": "Tirtha-Journal-Shared"} }
```

Response:

```json
{ "id": "ABcDef123", "productUrl":"...", "title":"Tirtha-Journal-Shared" }
```

```http
POST https://photoslibrary.googleapis.com/v1/albums/ABcDef123:share
Authorization: Bearer <GOOGLE_ACCESS_TOKEN>
Content-Type: application/json

{ "sharedAlbumOptions": { "isCollaborative": false, "isCommentable": false } }
```

Response contains `shareInfo.shareableUrl`.

### Google: batchAddMediaItems

```http
POST https://photoslibrary.googleapis.com/v1/albums/ABcDef123:batchAddMediaItems
Authorization: Bearer <GOOGLE_ACCESS_TOKEN>
Content-Type: application/json

{ "mediaItemIds": ["ABC123","DEF456"] }
```

### GitHub create file (Contents API)

```http
PUT https://api.github.com/repos/<owner>/<repo>/contents/stories/2025-03-28-bangkok-morning-walk.md
Authorization: Bearer <GITHUB_PAT>
Accept: application/vnd.github+json

{
  "message": "Add story: Slow Morning in Bangkok",
  "content": "<BASE64_ENCODED_MARKDOWN>",
  "committer": { "name":"Tirtha", "email":"you@example.com" },
  "branch": "main"
}
```

### Pseudocode (publish workflow)

```python
def publish(draft):
    ensure_valid_google_token()
    album_id, share_url = get_or_create_shared_album()
    add_media_to_album(album_id, draft.media_item_ids)
    markdown = build_markdown(draft, share_url, album_id)
    filename = generate_slug_filename(draft.date, draft.title)
    pat = secure_storage.get_github_pat()
    existing = github_get_file_if_exists(filename, pat)
    if existing:
        github_update_file(filename, markdown, existing.sha, pat)
    else:
        github_create_file(filename, markdown, pat)
    return { "ok": True, "url": site_story_url(filename) }
```

---

# 14 ‚Äî Implementation checklist & rollout plan

### Phase 0 ‚Äî Prep & accounts

* [ ] Create Google Cloud project, enable Photos Library API & Picker, configure OAuth consent (Testing), create Android OAuth client (package name + SHA-1).
* [ ] Prepare GitHub repo and create fine-grained PAT (repo-scoped with write to contents). Save PAT in a secure password manager until app runtime.
* [ ] Configure Vercel project connected to GitHub repo.

### Phase 1 ‚Äî Scaffold

* [ ] Create repo layout: `app/`, `webapp/`, `stories/`, `.github/`, `scripts/`.
* [ ] Bootstrap `app` with Expo + React Navigation + TS.
* [ ] Bootstrap `webapp` with Next.js + Tailwind + markdown parsing.

### Phase 2 ‚Äî Core features (MVP)

* [ ] Implement local drafts storage in Expo app.
* [ ] Implement simple markdown editor screen.
* [ ] Implement mock picker for local dev (returns fake media ids).
* [ ] Implement `scripts/validate-stories.js` and CI config.
* [ ] Implement GitHub commit logic (using PAT) with secure storage (Expo SecureStore).
* [ ] Implement building markdown and creating/updating files on GitHub.
* [ ] Implement album creation + share logic (Photos API) with mock for dev.
* [ ] Implement batchAddMediaItems to add selected items to album.
* [ ] Hook Next.js to read `stories/` and render story pages.

### Phase 3 ‚Äî Polish & resilience

* [ ] Implement Google Picker integration in Expo (WebView-based or native).
* [ ] Implement real Google OAuth token management (refresh, reauth).
* [ ] Offline queue + retry logic.
* [ ] Thorough error handling & UI (progress, actionable errors).
* [ ] Add CI validation steps in `.github/workflows/ci.yml`.

### Phase 4 ‚Äî Hardening

* [ ] Productionize OAuth (if you want to avoid re-auth; perform app verification).
* [ ] Consider GitHub App if you want better security in the long run.
* [ ] Optional rehosting flow if you decide to move to GCS/S3.

---

# 15 ‚Äî Appendix: references & why we chose options

**Why Google Photos Library + albums.share?**

* Gives the ‚Äúselect in Google Photos, publish, readers see media hosted by Google‚Äù UX you wanted, with a programmatic album shareable URL.
* `baseUrl` instability forced us to use album-level shareable URL rather than per-item baseUrls.

**Why fine-grained PAT + Contents API?**

* Simple and direct approach to create/update a Markdown file in GitHub programmatically.
* Fine-grained PAT minimizes security blast radius and is suitable for single-user personal apps.

**Why Expo RN + Next.js?**

* Expo: fastest to iterate on Android; easy to publish a private APK.
* Next.js: excellent SSG performance for Markdown-based site; works well with Vercel.

**Research sources (summary)**

* Google Photos Library API docs (albums.create, albums.share, batchAddMediaItems, picker session).
* Google Picker / Photos Picker documentation and notes on `baseUrl` lifetime.
* GitHub Contents API docs and guidance on fine-grained PATs & GraphQL `createCommitOnBranch`.
* Community notes (StackOverflow, blog posts) about direct Google Photos share URL fragility and practical picker usage.
